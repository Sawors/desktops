#!/bin/env python3
from os import system
from os import path
import os
from sys import argv
from time import time
import stat
#from plyer import notification
import subprocess
import glob
import yaml
import tempfile
import shutil
# fetching backends interfaces


# TODO 
#   - [ ] add program config support
#   - [ ] change language (to a compiled/packaged one, java/rust/dart)
#   - [ ] create README
#   - [ ] add to git
#   - [ ] split code into dedicated classes and interfaces
#

# general
root = "/etc/desktops"
computers = "hardware"
defaultHardwareLocation = f"/usr/share/desktops/{computers}"
hardwareLocations = [defaultHardwareLocation, f"{root}/{computers}"]
currentUsedConfig = f"{tempfile.gettempdir()}/desktops_current"
configFormat = "components.yml"
unknownConfig = f"{defaultHardwareLocation}/unknown_config"
displayIdentifier = "Display"
memoryIdentifier = "memory"
cpuIdentifier = "cpu"
rootScriptIdentifier = "root-launch.sh"
userScriptIdentifier = "user-launch.sh"
userConfigLocation = f".config/desktops/{computers}"
# ideally sorted in order, from quickest to slowest
fetchComponents = ["Board","CPU","Memory","GPU","Display"]

# arguments
EXACT_MATCH = "--exact-match" in argv or "-m" in argv
PARTIAL_FETCH = "--partial" in argv or "-p" in argv
WRITE_CONFIG = not ("--no-write" in argv or "-r" in argv)
VERBOSE = "--verbose" in argv or "-v" in argv

# partial fetch
partialFetchComponents = ["Board","CPU","Memory"]


# takes raw data, and attempts to make it standardized.
# Data should be split with one component per key (and monitor amount pre-computed)
# this methods DOES NO ALTER THE BASE COLLECTION, but it does clone it, thus increasing memory footprint
# NOTE : this method works for fast fetch only
# TODO : move this to the fastfetch implementation
def standardizeData(rawData: dict) -> dict:
    data = rawData.copy()
    for rawKey in rawData.keys():
        value = str(rawData[rawKey])
        key = rawKey.lower()

        if key == memoryIdentifier and "/" in value and "(" in value:
            value = value[value.find("/")+2:value.find("(")-1]
        elif key == cpuIdentifier and "@" in value:
            value = value[0:value.find("@")-1]
            
        data[key] = value
    return data


def trimConfigName(configPath:str) -> str:
    trimmed = str(configPath)
    if f"/{configFormat}" in trimmed.lower():
        trimmed = trimmed[0:trimmed.rfind(f"/{configFormat}")]
    if "/" in trimmed:
        trimmed = trimmed[trimmed.rfind("/")+1:len(trimmed)]

    return trimmed

def printVerbose(text: str):
    if VERBOSE: print(text)

def writeConfig(config_dir: str):
    if not WRITE_CONFIG: 
        printVerbose("read only mode, config will not be written to disk")
        return
    baseDir = config_dir if (path.isdir(config_dir) or not path.exists(config_dir)) else path.dirname(config_dir)
    if not path.isdir(baseDir): os.makedirs(baseDir)

    configName = trimConfigName(baseDir)

    try:
        with open(currentUsedConfig, "w") as current:
            current.write(f"{configName}\n{baseDir}\n")
            os.chmod(current.name, stat.S_IRUSR | stat.S_IWUSR |  stat.S_IROTH | stat.S_IRGRP | stat.S_IWGRP)
    except PermissionError as p:
        print(f"[!] Could not write config to disk, permission denied!")


def loadComponents(components: list) -> dict:
    output = ""
    componentStr = ""
    for c in components:
        componentStr += f"{c}:"
    componentStr = componentStr[0:len(componentStr)-1]
    
    try:
        output = subprocess.check_output(f"fastfetch --pipe -s {componentStr} --multithreading", shell=True).decode("UTF-8")
    except subprocess.CalledProcessError :
        print("an error occured when fetching the data !")
        print("no config found")
        writeConfig(unknownConfig)
        
    fetched = output.strip().splitlines()

    dataMap = {}
    monitorAmount = 0

    for entry in fetched :
        if entry.startswith(displayIdentifier):
            # do not count monitors with a height smaller than 1080 pixels (to avoid detecting fake monitors)
            if(int(entry.split("x")[1][0:4]) < 1080):
                continue
            monitorAmount+=1
        else:
            duo = entry.split(":")
            key = str(duo[0])
            data = duo[1].strip()
                
            dataMap[str(duo[0]).lower()] = data
    if displayIdentifier in components:
        dataMap["monitors"] = monitorAmount

    return standardizeData(dataMap)


# returns the number of matching fields (so that a general config may be applied if all other fail and exact match is set to false)
def matchConfig(config: str, dataMap: dict, exactMatch=False) -> int:
    if (not path.isfile(config)) or dataMap == None or len(dataMap) == 0: return 0
    matching = 0
    try:
        with open(config) as configRawData :
            data = standardizeData(yaml.safe_load(configRawData))

            if exactMatch and data == dataMap: return len(dataMap)

            # if exactMatch is not specified, it will attempt to find the closest config it can find
            for field in data.keys() :
                if field in dataMap and data[field].lower() == dataMap[field].lower(): 
                    matching += 1
    except e as PermissionError:
        print(f"Config {config} could not be loaded due to unsufficient permissions")

    return matching


# returns a dict containing the paths to the configs found. It loads the configs found in the users home directory
# and the ones defines in TODO config.yml
def loadConfigs() -> set:
    userConfigs = set()
    homeDir = "/home"
    if not path.isdir(homeDir): return userConfigs
    for user in glob.glob(root_dir=homeDir,recursive=False,pathname="*/"):
        configRoot = f"{homeDir}/{user}{userConfigLocation}"
        if not (path.isdir(configRoot)) : continue
        for configName in glob.glob(root_dir=configRoot, pathname=f"*/{configFormat}", recursive=True):
            userConfigs.add(f"{configRoot}/{configName}")

    for rootpath in hardwareLocations :
        for config in glob.glob(root_dir=rootpath, recursive=True, pathname=f"*/{configFormat}"):
                userConfigs.add(f"{rootpath}/{config}")
    
    return userConfigs


def detect():
    
    startTime = time()
    dataMap = loadComponents(fetchComponents)
    fetchTime = round((time()-startTime)*1000)
    printVerbose(f"fetching took {fetchTime}ms")
    dataSize = len(dataMap)
    printVerbose(f"hardware: {dataMap}")

    foundConfigs = loadConfigs()
    printVerbose(f"found {len(foundConfigs)} hardware configs")
    matchMap = {}

    for configPath in foundConfigs:
        matchMap[configPath] = matchConfig(config=configPath, dataMap=dataMap, exactMatch=EXACT_MATCH)
    
    config = None
    configPath = ""

    sortedMatches = sorted(matchMap.items(), key=lambda k:k[1], reverse=True)

    if not (len(sortedMatches) == 0 or (EXACT_MATCH and sortedMatches[0][1] != dataSize)):
        bestMatch = sortedMatches[0]
        configPath = path.dirname(bestMatch[0])
        config = trimConfigName(configPath)
        if EXACT_MATCH:
            printVerbose("exact match mode specified")
        if bestMatch[1] == dataSize:
            print(f"config [{config}] exactly matched !")
        elif not EXACT_MATCH:
            print(f"using config [{config}] with {bestMatch[1]}/{dataSize} matches")


    if config != None:
        writeConfig(configPath)
    else:
        print("No config found! Using unknown_config instead.")
        writeConfig(unknownConfig)
            
    totalTime = round((time()-startTime)*1000)
    printVerbose(f"config matching done in {totalTime-fetchTime}ms")
    printVerbose(f"complete config detection done in {totalTime}ms")

def partialDetect():
    if EXACT_MATCH: 
        detect()
        return

    foundConfigs = loadConfigs()
    printVerbose(f"found {len(foundConfigs)} hardware configs")
    
    startTime = time()
    dataMap = loadComponents(partialFetchComponents)
    printVerbose(f"initial fetch done in {round((time()-startTime)*1000)}ms")

    unusedComponents = [""]

    for c in fetchComponents:
        if not c in partialFetchComponents: unusedComponents.append(c)

    refetchAmount = 0
    for i in unusedComponents:
        if len(i) > 0: 
            dataMap.update(loadComponents({i}))
            refetchAmount += 1
        
        matchMap = {}  
        for configPath in foundConfigs:
            matchMap[configPath] = matchConfig(config=configPath, dataMap=dataMap, exactMatch=EXACT_MATCH)
        maxMatches = max(matchMap.values())

        matching = []
        for k,v in matchMap.items():
            if v == maxMatches : matching.append(k)

        if len(matching) <= 1:
            if len(matching) == 0:
                print("No config found! Using unknown_config instead.")
                writeConfig(unknownConfig)
            else:
                # partial match case
                config = matching[0]
                print(f"using config [{trimConfigName(config)}] with {matchMap[config]} matches")
                writeConfig(config)
            break
    
    totalTime = round((time()-startTime)*1000)
    printVerbose(f"config matching done with {refetchAmount} additionnal fetch{'es' if refetchAmount > 1 else ''}")
    printVerbose(f"complete config detection done in {totalTime}ms")
    

def getStartupScripts(configDir: str, identifier: str) -> list:
    dirPath = configDir if path.isdir(configDir) else path.dirname(configDir)
    configs = []
    if not path.isdir(dirPath): return configs

    if dirPath[len(dirPath)-1] == '/': dirPath = dirPath[0:len(dirPath)-2]
    genConfigFile = f"{dirPath}/{identifier}"
    if path.isfile(genConfigFile) : configs.append(genConfigFile)

    if identifier == userScriptIdentifier:
        userConfig = path.expanduser(f"~/.config/desktops/{computers}/{trimConfigName(configDir)}/{userScriptIdentifier}")
        if path.isfile(userConfig): configs.append(userConfig)
    
    return configs
    

def apply(args: list):
    # the config will be applied as the current user. For any operation requiring root privileges please edit /etc/sddm/Xsetup.
    passedArgument = ""
    for typeArg in args:
        if typeArg.startswith("--type=") or typeArg.startswith("-t="):
            passedArgument = typeArg[typeArg.index('=')+1:len(typeArg)]
            break
        
    config = None
    scripts = [None]*2

    isRoot = "--root" in args or "-r" in args

    def checkSure():
        sure = input("Are you sure this is what you want to do ? (y/N): ").lower() in ["y","yes"]
        if not sure:
            print("User cancelation, aborting sequence.")
            exit()

    if isRoot and os.geteuid() != 0:
        print("Applying root config as a non-root user, this is not an intended usage.")
        checkSure()
    elif (not isRoot) and os.geteuid() == 0:
        print("Root user detected, automatically switching to root mode (--root)")
        isRoot = True

    if isRoot:
        print("applying root startup scripts")
    else:
        print(f"applying user startup scripts for user [{os.getlogin()}]")

    # general config launch script
    configDir = None
    if not path.isfile(currentUsedConfig):
        print("Current used config file not found, please do a config detection first!")
    try:
        with open(currentUsedConfig, "r") as current:
            lines = current.readlines()
            config = lines[0].strip()
            configPath = lines[1].strip()
            configDir = configPath if path.isdir(configPath) else path.dirname(configPath)
    except:
        print(f"Access to current config in {currentUsedConfig} refused : Unsufficient permission")
        exit()
    
    if config == None or len(config) == 0:
            print("No config found!")
            exit(1)

    # user-specific launch script
    scripts = getStartupScripts(configDir, rootScriptIdentifier if isRoot else userScriptIdentifier)
    successfulScripts = 0

    for s in scripts:
        try:
            if not s == None and not len(s) == 0: 
                system(f"{s} {passedArgument}")
                successfulScripts += 1
        except:
            print(f"Permissions to run {s} denied !")
            if isRoot:
                print("Please run this program with root privileges when using --root or -r !")

    if not isRoot:
        try:
            system(f"notify-send \"Desktops\" \"Config [{config}] {'applied' if successfulScripts > 0 else 'FAILED TO BE APPLIED'} !\"")
        except:
            print("notification could not be sent! THIS IS NOT AN ERROR BUT A BAD IMPLEMENTATION")
    print(f"Launch script execution done ({successfulScripts}/{len(scripts)})")

def benchmark() -> dict:
    compSet = fetchComponents
    components = loadComponents(compSet)
    configs = loadConfigs()
    fetchTimes = {}
    fetchResult = {}
    print(f"Split fetch timings :")
    for identifier in compSet:
        baseTime = time()
        try:
            output = subprocess.check_output(f"fastfetch --pipe -s {identifier} --multithreading", shell=True).decode("UTF-8")
            fetchTimes[identifier] = round((time()-baseTime)*1000)
            fetchResult[identifier] = output
        except subprocess.CalledProcessError :
            print("an error occured when fetching the data !")

    totalTime = sum(fetchTimes.values())
    for k,v in sorted(fetchTimes.items(), key=lambda k:k[1], reverse=False):
        print(f"    - fetched {k} in {v}ms ({round(100*v/totalTime)}%)")
    print(f"    ==> all fetches took {totalTime}ms in total")
    print("\nStarting merged fetch benchmark...")
    startTime = time()
    mergedList = loadComponents(compSet)
    print(f"    ==> merged fetch took {round((time()-startTime)*1000)}ms")
    print(f"\nHardware : ==> {mergedList}")
    return mergedList

def test(benchmarkFetch = True, listConfigs = True, listScripts = True):

    partialDetect()
    exit()
    
    hardware = {}
    configs = []

    if benchmarkFetch: 
        print("Starting benchmarking sequence...")
        hardware = benchmark()
        
    if listConfigs: 
        print("\nListing hardware configs...")
        configs = {}
        if len(hardware) == 0: hardware = loadComponents(fetchComponents)

        for c in loadConfigs():
            configs[c] = matchConfig(c,hardware)
        
        for c in sorted(configs.items(), key=lambda k:k[1], reverse=True):
            print(f"    - {trimConfigName(c[0])} : {c[0]}")
            print(f"      matches: {c[1]}/{len(hardware)}")
        print(f"    ==> {len(configs)} config{'s' if len(configs) > 1 else ''} found")
            
    if listScripts: 
        print("\nListing startup scripts...")
        if len(configs) == 0: configs = loadConfigs()

        for c in configs:
            print(f"    [{trimConfigName(c)}] :")
            print( "        root :")
            for sc in getStartupScripts(c, rootScriptIdentifier):
                print(f"        - {sc}")
            print( "        user :")
            for sc in getStartupScripts(c, userScriptIdentifier):
                print(f"        - {sc}")


def create(name:str):
    dataMap = loadComponents(fetchComponents)
    configPath = f"{defaultHardwareLocation}/{name}"
    if path.exists(configPath):
        print(f"Config [{name}] already exists!\nAborting creation")
        exit()
        
    try:
        os.makedirs(configPath)
    except Exception as e:
        print(f"Config directory creation failed, aborting operation ({repr(e)})")
        exit()

    print(f"config will be created at {configPath}/")
    print(f"this hardware will be used for config:")
    for k in dataMap:
        print(f"    - {k}: {dataMap[k]}")
    # write config
    try:
        with open(f"{configPath}/{configFormat}", "w") as targetFile:
            yaml.safe_dump(data=dataMap,stream=targetFile)
        with open(f"{configPath}/{rootScriptIdentifier}", "w") as targetFile:
            targetFile.write("# root startup script goes here")
            os.chmod(targetFile.name, stat.S_IXUSR | stat.S_IRUSR | stat.S_IWUSR |  stat.S_IROTH | stat.S_IRGRP)
        with open(f"{configPath}/{userScriptIdentifier}", "w") as targetFile:
            targetFile.write("# user startup script goes here")
            os.chmod(targetFile.name, stat.S_IXUSR | stat.S_IRUSR | stat.S_IWUSR |  stat.S_IROTH | stat.S_IRGRP)
    except Exception as e:
        print(f"Config file creation failed, aborting operation ({repr(e)})")
        try:
            shutil.rmtree(configPath)
        except:
            print("Config cleanup failed")



##################################################
#                                                #
#  End of definitions, beginning of script flow  #
#                                                #
##################################################

try:
    hardwareLocations.append(f"{path.dirname(argv[0])}/{computers}")
except:
    print("Current directory not usable for hardware detection")

if len(argv) < 2:
    print("""
    Please specify an action.

    Possible actions are :
        detect
        apply
        create
        test""")
    exit()

argument = argv[1]

match argument:
    case "detect":
        try:
            subprocess.run("fastfetch -v", shell=True, capture_output=True, check=True)
        except subprocess.CalledProcessError:
            print("ERROR : fastfetch not found! please ensure fastfetch is present and available.\nAborting detection!")
            
            exit()
        
        print("Detecting hardware configuration...")
        if PARTIAL_FETCH:
            printVerbose("using partial detection")
            partialDetect()
        else:
            detect()

    case "test":
        if len(argv) == 2 : test()
        else:
            test(
                benchmarkFetch = "--benchmark" in argv or "--hardware" in argv,
                listConfigs = "--configs" in argv,
                listScripts = "--scripts" in argv,
            )
        
    case "apply":
        print("Launching startup script...")
        apply(argv)

    case "create":
        name = ""
        for a in argv:
            if a.startswith("--name=") or a.startswith("-n="):
                name = a[a.index("=")+1:len(a)]
                break
        if len(name) < 1 and len(argv) >= 3 and len(argv[2]) > 0 and not argv[2].startswith("-"):
            name = argv[2]
        if len(name) > 0:
            print(f"Creating config [{name}]...")
            create(name)
            print("Config creation done!")
        else:
            print("Please input a name for the config, either using --name=<name> or by putting it as the argument after \"create\"")
exit()
